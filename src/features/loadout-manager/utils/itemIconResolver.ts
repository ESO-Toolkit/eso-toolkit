/**
 * Item Icon Resolver
 *
 * Resolves ESO item icons using a pre-fetched local JSON file
 * (generated by scripts/fetch-item-icons.mjs) containing 154K+ item→icon
 * mappings from UESP's minedItemSummary table. Zero runtime API calls
 * needed for any item in the local data.
 *
 * Falls back to the UESP API for items not in the local data (e.g., new
 * items added after the last data refresh).
 *
 * CDN: https://esoicons.uesp.net/esoui/art/icons/{iconName}.png
 *
 * To refresh the local data:
 *   node scripts/fetch-item-icons.mjs
 */

import { Logger } from '@/utils/logger';

// Pre-fetched icon data: { icons: string[], items: Record<string, number> }
import iconData from '../data/itemIcons.json';

const logger = new Logger({ contextPrefix: 'ItemIconResolver' });

/** Base URL for the UESP icon CDN */
const UESP_ICON_CDN = 'https://esoicons.uesp.net';

/** Base URL for the UESP item data API (fallback only) */
const UESP_API = 'https://esolog.uesp.net/exportJson.php';

/** Runtime cache for items resolved via API fallback */
const fallbackCache = new Map<number, string | null>();

/** Pending fetch promises so we don't start duplicate requests */
const pendingFetches = new Map<number, Promise<string | null>>();

/**
 * Build a CDN URL from an icon name.
 *   "gear_undnarlimor_head_a" → "https://esoicons.uesp.net/esoui/art/icons/gear_undnarlimor_head_a.png"
 */
function iconNameToUrl(iconName: string): string {
  return `${UESP_ICON_CDN}/esoui/art/icons/${iconName}.png`;
}

/**
 * Look up an item's icon URL from the local pre-fetched data.
 * Returns a CDN URL, or null if the item isn't in the local data.
 */
function lookupLocal(itemId: number): string | null {
  const typedData = iconData as { icons: string[]; items: Record<string, number> };
  const index = typedData.items[String(itemId)];
  if (index === undefined) return null;
  const iconName = typedData.icons[index];
  if (!iconName) return null;
  return iconNameToUrl(iconName);
}

/**
 * Fetch the icon URL for a single item from UESP (fallback).
 * Only called for items not present in the local JSON data.
 */
async function fetchIconFromUESP(itemId: number): Promise<string | null> {
  try {
    const url = `${UESP_API}?table=minedItemSummary&id=${itemId}`;
    const response = await fetch(url);

    if (!response.ok) {
      logger.warn('UESP API returned non-OK status', { itemId, status: response.status });
      return null;
    }

    const data = await response.json();
    const item = (data.minedItemSummary as Array<{ icon?: string }>)?.[0];
    if (!item?.icon || typeof item.icon !== 'string') return null;
    if (item.icon.includes('icon_missing')) return null;

    // Convert DDS path → PNG CDN URL
    const match = item.icon.match(/([^/]+)\.dds$/i);
    return match ? iconNameToUrl(match[1]) : null;
  } catch (err) {
    logger.warn('Failed to fetch icon from UESP', {
      itemId,
      error: err instanceof Error ? err.message : String(err),
    });
    return null;
  }
}

/**
 * Get the icon URL for a given item ID (synchronous).
 *
 * Checks the local pre-fetched data first (instant), then
 * the runtime fallback cache. Returns null if not available locally
 * and no fallback result is cached yet.
 */
export function getItemIconUrl(itemId: number | null | undefined): string | null {
  if (!itemId || itemId <= 0) return null;

  // 1. Check local pre-fetched data (instant, ~154K items)
  const local = lookupLocal(itemId);
  if (local) return local;

  // 2. Check runtime fallback cache
  if (fallbackCache.has(itemId)) {
    return fallbackCache.get(itemId) ?? null;
  }

  return null;
}

/**
 * Async version: resolve an item's icon URL.
 *
 * Returns instantly from local data when possible, otherwise
 * falls back to a UESP API call (deduplicated).
 */
export async function fetchItemIconUrl(itemId: number): Promise<string | null> {
  if (itemId <= 0) return null;

  // 1. Check local pre-fetched data (instant)
  const local = lookupLocal(itemId);
  if (local) return local;

  // 2. Check runtime fallback cache
  if (fallbackCache.has(itemId)) {
    return fallbackCache.get(itemId) ?? null;
  }

  // 3. Join an existing in-flight fetch
  const pending = pendingFetches.get(itemId);
  if (pending) return pending;

  // 4. Fall back to UESP API for unknown items
  logger.info('Item not in local data, fetching from UESP', { itemId });
  const fetchPromise = fetchIconFromUESP(itemId).then((url) => {
    fallbackCache.set(itemId, url);
    pendingFetches.delete(itemId);
    return url;
  });

  pendingFetches.set(itemId, fetchPromise);
  return fetchPromise;
}

/**
 * Pre-populate results for a batch of item IDs.
 * Only makes API calls for items not already in the local data.
 */
export async function prefetchItemIcons(itemIds: number[]): Promise<void> {
  const needsFetch = itemIds.filter((id) => id > 0 && !lookupLocal(id) && !fallbackCache.has(id));

  const unique = [...new Set(needsFetch)];
  for (const id of unique) {
    await fetchItemIconUrl(id);
    await new Promise((r) => setTimeout(r, 50));
  }
}

import fs from 'fs';
import path from 'path';
import crypto from 'crypto';
import { OperationVariables } from '@apollo/client';

/**
 * Utilities for caching ESO Logs API responses during testing
 * This helps reduce API calls and avoid rate limiting during test runs
 */

const CACHE_DIR = path.join(__dirname, '..', 'cache');

/**
 * Ensures the cache directory exists
 */
export function ensureCacheDir(): void {
  if (!fs.existsSync(CACHE_DIR)) {
    fs.mkdirSync(CACHE_DIR, { recursive: true });
  }
}

/**
 * Generates a cache key based on operation name, variables, and endpoint
 * @param operationName The GraphQL operation name
 * @param variables The operation variables
 * @param endpoint The API endpoint being called (client or user)
 * @returns A unique cache key for this operation
 */
export function generateCacheKey(
  operationName: string,
  variables: OperationVariables = {},
  endpoint: 'client' | 'user' = 'client'
): string {
  // Sort variables to ensure consistent key generation
  const sortedVars = JSON.stringify(variables, Object.keys(variables).sort());
  const content = `${operationName}:${endpoint}:${sortedVars}`;
  
  // Create a hash to ensure filename safety and uniqueness
  const hash = crypto.createHash('sha256').update(content).digest('hex').substring(0, 16);
  
  // Return a human-readable cache key
  return `${operationName}_${endpoint}_${hash}.json`;
}

/**
 * Reads cached response for the given cache key
 * @param cacheKey The cache key generated by generateCacheKey
 * @returns The cached response or null if not found
 */
export function readCachedResponse<T = any>(cacheKey: string): T | null {
  try {
    const cachePath = path.join(CACHE_DIR, cacheKey);
    if (!fs.existsSync(cachePath)) {
      return null;
    }
    
    const content = fs.readFileSync(cachePath, 'utf-8');
    return JSON.parse(content);
  } catch (error) {
    console.warn(`Failed to read cache for key ${cacheKey}:`, error);
    return null;
  }
}

/**
 * Writes response to cache
 * @param cacheKey The cache key generated by generateCacheKey
 * @param response The response data to cache
 */
export function writeCachedResponse<T = any>(cacheKey: string, response: T): void {
  try {
    ensureCacheDir();
    const cachePath = path.join(CACHE_DIR, cacheKey);
    fs.writeFileSync(cachePath, JSON.stringify(response, null, 2), 'utf-8');
  } catch (error) {
    console.warn(`Failed to write cache for key ${cacheKey}:`, error);
  }
}

/**
 * Clears all cached responses
 */
export function clearCache(): void {
  try {
    if (!fs.existsSync(CACHE_DIR)) {
      return;
    }
    
    const files = fs.readdirSync(CACHE_DIR);
    for (const file of files) {
      if (file.endsWith('.json')) {
        fs.unlinkSync(path.join(CACHE_DIR, file));
      }
    }
    
    console.log('Cache cleared successfully');
  } catch (error) {
    console.warn('Failed to clear cache:', error);
  }
}

/**
 * Gets cache statistics
 */
export function getCacheStats(): { fileCount: number; totalSize: number; files: string[] } {
  try {
    if (!fs.existsSync(CACHE_DIR)) {
      return { fileCount: 0, totalSize: 0, files: [] };
    }
    
    const files = fs.readdirSync(CACHE_DIR).filter(f => f.endsWith('.json'));
    let totalSize = 0;
    
    for (const file of files) {
      const stats = fs.statSync(path.join(CACHE_DIR, file));
      totalSize += stats.size;
    }
    
    return {
      fileCount: files.length,
      totalSize,
      files
    };
  } catch (error) {
    console.warn('Failed to get cache stats:', error);
    return { fileCount: 0, totalSize: 0, files: [] };
  }
}
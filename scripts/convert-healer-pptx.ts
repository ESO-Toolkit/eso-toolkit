/*
  Script: scripts/convert-healer-pptx.ts
  Purpose: Extract a hierarchical outline from a PPTX file and write a typed TS module
           at src/data/Roles/healer/HealerOutline.ts

  Usage (after installing deps):
    npx tsx scripts/convert-healer-pptx.ts
*/

import fs from 'fs';
import path from 'path';
import JSZip from 'jszip';
import { XMLParser } from 'fast-xml-parser';

const PPTX_REL_PATH = 'src/data/Roles/healer/Healing Basics-By BerryBellBell.pptx';
const OUTPUT_TS_PATH = 'src/data/Roles/healer/HealerOutline.ts';

interface OutlineItem {
  level: number; // 0 = title-level, 1+ = bullet indent levels
  text: string;
}

interface OutlineSlide {
  index: number; // 1-based slide number
  title: string;
  items: OutlineItem[];
}

interface HealerOutline {
  slides: OutlineSlide[];
}

function toArray<T>(v: T | T[] | undefined): T[] {
  if (!v) return [];
  return Array.isArray(v) ? v : [v];
}

async function extractOutline(buffer: Buffer): Promise<HealerOutline> {
  const zip = await JSZip.loadAsync(buffer);
  const slideEntries = Object.keys(zip.files)
    .filter((k) => k.startsWith('ppt/slides/slide') && k.endsWith('.xml'))
    .sort((a, b) => {
      const na = parseInt(a.match(/slide(\d+)\.xml$/)?.[1] || '0', 10);
      const nb = parseInt(b.match(/slide(\d+)\.xml$/)?.[1] || '0', 10);
      return na - nb;
    });

  const parser = new XMLParser({
    ignoreAttributes: false,
    attributeNamePrefix: '',
    textNodeName: 'text',
  });

  const slides: OutlineSlide[] = [];

  for (const slidePath of slideEntries) {
    const slideXml = await zip.files[slidePath].async('text');
    const s = parser.parse(slideXml);

    // Typical shape tree at p:sld -> p:cSld -> p:spTree
    const spTree = s?.['p:sld']?.['p:cSld']?.['p:spTree'];
    if (!spTree) {
      slides.push({ index: slides.length + 1, title: '(Untitled Slide)', items: [] });
      continue;
    }

    // Shapes (text boxes) live under p:sp, can be array or single
    const shapes = toArray<any>(spTree['p:sp']);

    let title = '';
    const items: OutlineItem[] = [];

    for (const sp of shapes) {
      const txBody = sp?.['p:txBody'];
      const paragraphs = toArray<any>(txBody?.['a:p']);
      for (const p of paragraphs) {
        // Gather text from runs a:r -> a:t
        const runs = toArray<any>(p?.['a:r']);
        let text = '';
        if (runs.length > 0) {
          for (const r of runs) {
            const t = r?.['a:t'];
            if (typeof t === 'string') text += t;
          }
        } else {
          // Some paragraphs store text directly in a:fld or a:t
          const t = p?.['a:fld']?.['a:t'] ?? p?.['a:t'];
          if (typeof t === 'string') text += t;
        }
        if (!text.trim()) continue;

        // Determine bullet level from paragraph properties a:pPr lvl="N"
        // Default to level 0 if missing
        const lvlRaw = p?.['a:pPr']?.['lvl'];
        const level = typeof lvlRaw === 'number' ? lvlRaw : parseInt(lvlRaw || '0', 10) || 0;

        if (!title) {
          title = text.trim();
        } else {
          items.push({ level, text: text.trim() });
        }
      }
    }

    slides.push({ index: slides.length + 1, title: title || '(Untitled Slide)', items });
  }

  return { slides };
}

function toTs(outline: HealerOutline): string {
  const esc = (s: string) => s.replace(/`/g, '\\`').replace(/\\/g, '\\\\').replace(/\$/g, '$$$$');
  const slidesTs = outline.slides
    .map((sl) => {
      const itemsTs = sl.items
        .map((it) => `      { level: ${it.level}, text: \`${esc(it.text)}\` }`)
        .join(',\n');
      return `  { index: ${sl.index}, title: \`${esc(sl.title)}\`, items: [\n${itemsTs}\n  ] }`;
    })
    .join(',\n');

  return `// Auto-generated by scripts/convert-healer-pptx.ts
// Do not edit manually.

export interface HealerOutlineItem { level: number; text: string }
export interface HealerOutlineSlide { index: number; title: string; items: HealerOutlineItem[] }
export interface HealerOutline { slides: HealerOutlineSlide[] }

export const healerOutline: HealerOutline = {
  slides: [
${slidesTs}
  ]
};

export default healerOutline;
`;
}

async function main() {
  const absPptx = path.resolve(PPTX_REL_PATH);
  if (!fs.existsSync(absPptx)) {
    console.error(`PPTX not found at: ${absPptx}`);
    process.exit(1);
  }
  const buffer = fs.readFileSync(absPptx);
  const outline = await extractOutline(buffer);
  const outTs = toTs(outline);
  const outPath = path.resolve(OUTPUT_TS_PATH);
  fs.writeFileSync(outPath, outTs, 'utf-8');
  console.log(`Wrote outline to: ${outPath}`);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});

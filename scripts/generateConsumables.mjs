import https from 'node:https';
import { writeFileSync } from 'node:fs';
import { fileURLToPath } from 'node:url';
import { dirname, resolve } from 'node:path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const SOURCE_URL = 'https://raw.githubusercontent.com/uesp/uesp-esolog/master/archive/esoRecipeData42.php';

const FOOD_CATEGORIES = new Set([
  'Meat Dishes',
  'Fruit Dishes',
  'Vegetable Dishes',
  'Gourmet',
  'Savouries',
  'Entremet',
  'Delicacies',
  'Ragout',
]);

const DRINK_CATEGORIES = new Set([
  'Alcoholic Drinks',
  'Tea',
  'Tonics',
  'Tinctures',
  'Liqueurs',
  'Cordial Teas',
  'Distillates',
]);

const ENTRY_REGEX = /(\d+)\s*=>\s*array\(\s*([-\d]+)\s*,\s*"([^"]*)"\s*,\s*"([^"]*)"\s*,\s*([-\d]+)\s*\)/g;

const fetchData = (url) => {
  return new Promise((resolvePromise, rejectPromise) => {
    https.get(url, (res) => {
      if (res.statusCode !== 200) {
        rejectPromise(new Error(`Request failed with status ${res.statusCode}`));
        res.resume();
        return;
      }

      let data = '';
      res.setEncoding('utf8');
      res.on('data', (chunk) => {
        data += chunk;
      });
      res.on('end', () => resolvePromise(data));
    }).on('error', (err) => rejectPromise(err));
  });
};

const cleanName = (name) => {
  const trimmed = name.trim();
  // Remove ESO plural markers like ^P or ^p
  return trimmed.replace(/\^[A-Za-z]+/, '');
};

const generate = async () => {
  const raw = await fetchData(SOURCE_URL);
  const entries = new Map();

  let match;
  while ((match = ENTRY_REGEX.exec(raw)) !== null) {
    const itemId = Number(match[1]);
    const recipeId = Number(match[2]);
    const category = match[3];
    const name = cleanName(match[4]);
    const quality = Number(match[5]);

    let type = null;
    if (FOOD_CATEGORIES.has(category)) {
      type = 'food';
    } else if (DRINK_CATEGORIES.has(category)) {
      type = 'drink';
    }

    if (!type) {
      continue;
    }

    entries.set(itemId, {
      id: itemId,
      recipeId,
      category,
      name,
      quality,
      type,
    });
  }

  const sortedEntries = Array.from(entries.values()).sort((a, b) => {
    return a.name.localeCompare(b.name, 'en', { sensitivity: 'base' });
  });

  const exportLines = sortedEntries.map((entry) => {
    const { id, recipeId, category, name, quality, type } = entry;
    // Escape backslashes first, then single quotes, to avoid incomplete sanitization
    const safeName = name.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
    const safeCategory = category.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
    return `  { id: ${id}, recipeId: ${recipeId}, category: '${safeCategory}', name: '${safeName}', quality: ${quality}, type: '${type}' },`;
  }).join('\n');

  const output = `/**\n * Auto-generated via scripts/generateConsumables.mjs\n * Source: ${SOURCE_URL}\n *\n * Do not edit this file manually.\n */\n\nexport type ConsumableType = 'food' | 'drink';\n\nexport interface EsoConsumable {\n  readonly id: number;\n  readonly recipeId: number;\n  readonly category: string;\n  readonly name: string;\n  readonly quality: number;\n  readonly type: ConsumableType;\n}\n\nexport const ESO_CONSUMABLES: readonly EsoConsumable[] = [\n${exportLines}\n] as const;\n\nexport const ESO_CONSUMABLE_LOOKUP: Readonly<Record<number, EsoConsumable>> = Object.freeze(\n  Object.fromEntries(ESO_CONSUMABLES.map((item) => [item.id, item])),\n);\n`;

  const outputPath = resolve(__dirname, '..', 'src', 'data', 'esoConsumables.ts');
  writeFileSync(outputPath, output, 'utf8');
  console.log(`Generated ${sortedEntries.length} consumables -> ${outputPath}`);
};

try {
  await generate();
} catch (error) {
  console.error('Failed to generate consumables:', error);
  process.exit(1);
}
